{"version":3,"file":"index.js","sources":["../src/index.js"],"sourcesContent":["const inBrowser = typeof window !== 'undefined'\n\nif(inBrowser){\n  window.createHelper = createHelper;\n}\n\nexport default function createHelper(config) {\n\n  if(config.Vue === undefined || config.router === undefined){\n    console.warn(\"warning: router helper needs Vue and root router ,see more for guide : https://github.com/Zippowxk/vue-router-keep-alive-helper\")\n    return;\n  }\n  const Vue = config.Vue;\n  const router = config.router;\n  const canRefresh = true; //fixed issue#2 https://github.com/Zippowxk/vue-router-keep-alive-helper/issues/2  config.canRefresh === undefined ? true : config.canRefresh;\n  let hacked = false;\n  // When 'canRefresh === true' ,RouterStack will make the stack visible in the query of URL path,\n  // Because when a page can refresh , the vm._stack chain is broken.\n  // The query.routerStack will be used as place B to keep the stack chain\n  router._stack = 0;\n  let pre;\n  let isReplace = false;\n\n  router.beforeEach((to, from, next) => {\n    pre = getCurrentVM();\n    next();\n  })\n\n  router.afterEach((to, from) => {\n    // get the vm instance after render\n    Vue.nextTick(() => {\n      if (pre === undefined) {\n        initialCb(to);\n      } else if (isReplace) {\n        replaceCb();\n      } else if (isPush(to)) {\n        pushCb();\n      } else {\n        backCb();\n      }\n      setCurrentVnodeKey();\n      const current = getCurrentVM();\n      if(!hacked){\n        hackKeepAliveRender(current.$vnode.parent.componentInstance);\n      }\n    })\n  })\n\n  // hack router.replace function\n  const rtmp = router.replace;\n  router.replace = function(arg, complete, abort) {\n    isReplace = true;\n    rtmp.apply(router, [arguments[0]]);\n  }\n\n  // hack the router.push , canRefresh mode only\n  if (canRefresh) {\n    const ptmp = router.push;\n    router.push = function(arg, complete, abort) {\n      if (canRefresh) {\n        const current = getCurrentVM()\n        if (typeof arg === 'string') {\n          arg = arg.indexOf('?') !== -1 ? arg + `&routerStack=${current._stack + 1}` : arg + `?routerStack=${current._stack + 1}`\n        } else {\n          if (!arg.query) {\n            arg.query = { 'routerStack': current._stack + 1 }\n          } else {\n            arg.query['routerStack'] = current._stack + 1;\n          }\n        }\n      }\n      ptmp.apply(router, [arguments[0]])\n    }\n  }\n\n  /*********** hack keep alive render *******************/\n\n  const hackKeepAliveRender = function(vm){\n\n    \n    // modify the first keep alive key and catch\n    replaceFirstKeyAndCache(vm,genKey(router._stack))\n    \n    const tmp = vm.$options.render\n    vm.$options.render = function(){\n      const slot = this.$slots.default;\n      const vnode = getFirstComponentChild(slot)\n      if(!isDef(vnode.key)){\n        if(isReplace){\n          vnode.key = genKey(router._stack)\n        }else if(isPush(router.history.current)){\n          vnode.key = genKey(Number(router._stack)+1)\n        }else{\n          vnode.key = genKey(Number(router._stack)-1)\n        }\n      }\n      return tmp.apply(this,arguments)\n    }\n    hacked = true;\n  }\n\n  /** ********* router helper ************/\n\n  const genKey = function(num){\n    return \"keep-alive\" + Number(num) + router.history.current.path\n  }\n\n  const getKeepAliveVM = function (){\n    const current = getCurrentVM();\n    return current?current.$vnode.parent.componentInstance:pre?pre.$vnode.parent.componentInstance:undefined;\n  }\n  const getCurrentVM = function() {\n    return router.history.current.matched.length > 0 ? router.history.current.matched[0].instances.default : undefined;\n  }\n  const getCurrentVMStack = function() {\n    return getCurrentVM() ? getCurrentVM()._stack : undefined;\n  }\n  const setCurrentVMStack = function(stack) {\n    router.history.current.matched.length > 0 && (router.history.current.matched[0].instances.default._stack = Number(stack));\n  }\n  const setCurrentVnodeKey = function() {\n    const current = getCurrentVM();\n    if (current && current._vnode) { \n      current._vnode.key = Number(router._stack) + router.history.current.path \n      current._vnode.parent.key = genKey(router._stack)\n    }\n  }\n  /** ********  callback functions ************/\n  const initialCb = function(to) {\n    if (canRefresh) {\n      if (to.query && to.query.routerStack !== undefined) {\n        setCurrentVMStack(to.query.routerStack);\n        router._stack = to.query.routerStack;\n      } else {\n        setCurrentVMStack(0);\n      }\n    } else {\n      setCurrentVMStack(0);\n    }\n  }\n  const pushCb = function() {\n    router._stack++;\n    setCurrentVMStack(router._stack)\n  }\n  const backCb = function() {\n    router._stack--;\n    if (getCurrentVMStack() === undefined) {\n      setCurrentVMStack(pre._stack - 1)\n    }\n    pre.$keepAliveDestroy();\n  }\n  const replaceCb = function() {\n    setCurrentVMStack(pre._stack)\n    pre.$keepAliveDestroy();\n    isReplace = false;\n  }\n  const isPush = function(to) {\n    // in normal , getCurrentVMStack is undefined only happened when push,\n    // But when refresh mode, getCurrentVMStack is undefined can also happened when popback\n    // In this case , the query.routerStack will be used instand of vm._stack\n\n    const toStack = to.query ? to.query.routerStack !== undefined ? to.query.routerStack : 0 : 0;    \n    return (getCurrentVMStack() === undefined && !canRefresh) || (canRefresh && toStack > pre._stack);\n  }\n\n  /** ******** depend functions ************/\n  // add $keepAliveDestroy function to every vm instance instand of $destroy function\n  // remove vnode in cache vnodes when destroy a keep-alive instance,\n  // just in case reuse previous vm instance of this vnode when push to the same page second time\n  const replaceFirstKeyAndCache = function(vm,key){\n    if(!isDef(vm) || !isDef(vm.cache) || !isDef(vm.keys)){return}\n    const keys = vm.keys;\n    const cache = vm.cache;\n    if(keys.length == 1){\n      const vnode = cache[keys[0]]\n      delete cache[keys[0]]\n      keys.splice(0,1);\n      keys.push(key);\n      cache[key] = vnode;\n    }\n  }\n\n\n  const dtmp = Vue.prototype.$destroy;\n  const f = function() {\n    if (this.$vnode && this.$vnode.data.keepAlive) {\n      if (this.$vnode.parent && this.$vnode.parent.componentInstance && this.$vnode.parent.componentInstance.cache) {\n        if (this.$vnode.componentOptions) {\n          var key = this.$vnode.key == null\n            ? this.$vnode.componentOptions.Ctor.cid + (this.$vnode.componentOptions.tag ? `::${this.$vnode.componentOptions.tag}` : '')\n            : this.$vnode.key;\n          var cache = this.$vnode.parent.componentInstance.cache;\n          var keys = this.$vnode.parent.componentInstance.keys;\n          if (cache[key]) {\n            if (keys.length) {\n              var index = keys.indexOf(key);\n              if (index > -1) {\n                keys.splice(index, 1);\n              }\n            }\n            delete cache[key];\n          }\n        }\n      }\n    }\n    dtmp.apply(this, arguments);\n  }\n  Vue.prototype.$keepAliveDestroy = f;\n\n  // getFirstChild \n  const getFirstComponentChild = function  (children){\n    if (Array.isArray(children)) {\n      for (let i = 0; i < children.length; i++) {\n        const c = children[i]\n        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n          return c\n        }\n      }\n    }\n  }\n  const isAsyncPlaceholder = function (node){\n    return node.isComment && node.asyncFactory\n  }\n  const isDef = function (v) {\n    return v !== undefined && v !== null\n  }\n}"],"names":["createHelper","config","undefined","Vue","router","pre","hacked","_stack","isReplace","beforeEach","to","from","next","getCurrentVM","afterEach","nextTick","initialCb","replaceCb","isPush","pushCb","backCb","setCurrentVnodeKey","current","hackKeepAliveRender","$vnode","parent","componentInstance","rtmp","replace","arg","complete","abort","apply","arguments","ptmp","push","indexOf","query","vm","replaceFirstKeyAndCache","genKey","tmp","$options","render","slot","this","$slots","default","vnode","getFirstComponentChild","isDef","key","history","Number","num","path","matched","length","instances","getCurrentVMStack","setCurrentVMStack","stack","_vnode","routerStack","$keepAliveDestroy","toStack","cache","keys","splice","dtmp","prototype","$destroy","data","keepAlive","componentOptions","Ctor","cid","tag","index","children","Array","isArray","i","c","isAsyncPlaceholder","node","isComment","asyncFactory","v","console","warn","window"],"mappings":"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"}